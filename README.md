#include<stdio. h>struct process {intprocessID; intburstTime; intarrivalTime; intpriority; intwaitTime; };inttotal_time,burst_time=0; inttotal=-1,i=-1;//tocalcualtenoofprocessenteredincpuanditoputresultincpu /*tomakebufferofqueueinwhichprocesswillbeentered andfinalprocessaftercompletiontobeenteredinresultofbuffer 100;*/structprocessqueue[100],result[100],swap; intprocess_create()//fornumberofinputs {intn; printf("enterthenumberofprocessyouwantto enter:");scanf("%d",&n); returnn; }voidexecute()////functiontoexecutetheprocess {if(total>=0)
{intwait,j; if(burst_time!=0&&queue[0].burstTime!=0) {queue[0].burstTime- -;burst_time--; queue[0].priority++; queue[0].arrivalTime=total_time+ 1;total_time++; //toincreasethewaitandpriorityofwaiting processfor(wait=1;wait<=total;wait++) {queue[wait].priority+=2; queue[wait].waitTime=++queue[wait].waitTi me; }}//ifprocessgetscompleted,itisputinresult queueif(queue[0].burstTime==0) {i++; result[i]=queue[0]; for(wait=0;wait<total;wait+ +){queue[wait]=queue[wait+1]; }total--; }//tosorttheprocessagaininbypriority for(wait=0;wait<total;wait++)
{for(j=0;j<total;j++) {if(queue[wait].priority<=queue[j].priority) {swap=queue[wait]; queue[wait]=queue[j]; queue[j]=swap; }}}if(queue[0].priority<=queue[1].priority&&total>=1) {swap=queue[0]; for(wait=0;wait<total;wait+ +){queue[wait]=queue[wait+1]; }queue[total]=swap; }}}voidmain() {intl,j,n=process_create(),count=0; floatavg_WaitTime=0; structprocess pcreate[n]; for(l=0;l<n;l++)
pcreate[l].processID=l+1; printf("\nEnterthearrivaltimeofprocess[%d]: ",l+1);scanf("%d",&pcreate[l].arrivalTime); printf("\nEnterthebursttimeofprocess[%d]:",l+1); scanf("%d",&pcreate[l].burstTime); pcreate[l].priority=0; pcreate[l].waitTime=0; burst_time=burst_time+pcreate[l].burstTi me; }for(l=0;l<n;l++) {for(j=0;j<n;j++) {if(pcreate[l].arrivalTime<pcreate[j].arrivalTime) {swap=pcreate[l]; pcreate[l]=pcreate[j] ;pcreate[j]=swap; }if(pcreate[l].arrivalTime==pcreate[j].arrivalTime) {if(pcreate[l].burstTime<=pcreate[j].burstTime) {swap=pcreate[l]; pcreate[l]=pcreate[j] ;pcreate[j]=swap; }}}
}//printingthesortedprocessidwithrespecttoarrivaltimeandifarrivaltimeisequalthan bursttime. printf("VALUESENTERED:\n*(TABLESORTEDACCORDINGTOTHEAARIVALTIME)\n\n"); printf(" PROCESSTABLE\n\n"); printf("PROCESSID ARRIVALTIME SERVICETIME\n\n"); for(l=0;l<n;l++) {printf(" %d %d %d\n\n",pcreate[l].processID,pcreate[l].arrivalTime,pcreate[l].burstTime); }total_time=pcreate[0].arrivalTime; for(j=pcreate[0].arrivalTime;j<=pcreate[n- 1].arrivalTime;j++) {for(l=0;l<n;l++) {if(pcreate[l].arrivalTime==j&&count!=n) {total++; queue[total]=pcreate[l] ;count++; }if(count== n)break; }execute(); total_time++; while(burst_time!=0&&count==n)
{execute(); total_time++; }if(count== n)break; }printf("PROCESSINORDEROFTHEIR COMPLETION:\n\n");printf(" FINALPROCESS EXECUTIONTABLE\n\n"); printf("PROCESSID ARRIVALTIME SERVICETIME WAITINGTIME\n"); for(l=0;l<n;l++) {for(j=0;j<n;j++) {if(result[l].processID==pcreate[j].processID) { printf(" %d %d %d %d\n\n",result[l].processID,pcreate[j].arrivalTime,pcreate[j].burstTime,result[l].waitTime); break; break; }}avg_WaitTime+=(result[l].waitTime); }printf("AVERAGEWAITINGTIME:%f\n",avg_WaitTime/n); }
